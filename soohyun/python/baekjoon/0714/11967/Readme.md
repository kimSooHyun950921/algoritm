# **1. 문제의 핵심**
- bfs
- 적당한 로직을 잘 만들 수 있는가?
    - 미방문이면서 방문할 수 있는곳을 어떻게 표시할 수 있는가?

# **2. 로직**
- 시작부분부터 시작
    - bfs에서 하나를 뽑음
    - 그 장소에서 불을 켤 수 있는 모든 불을 켬
    - 그 장소에서 인접한곳을 체크함(불이 켜진곳과 켜진곳 신경안씀)
    - 인접하면서, 불이 켜져 있으면서 방문하지 않았으면 큐에 넣는다.
- 불이 켜져있는곳을 모두 센다.

# **3. 복기할것(내가 못풀었던 이유)**
- 불을 켜고, 모든 인접한곳에서 *변하는곳* 이있으면 다음단계로 넘어가고, 변하는곳이 없으면 반복문을 멈추도록 했음
    - 예제문제에서 (1,2)에서는 스위치가 없어 변하는곳이 없어서 실제 답안으로 넘어가지 못했음
- 변하는곳이 아니라, 인접한곳, 불이 켜져 있는곳 방문여부를 모두 따져서 큐에 넣도록 해야한다.
# **4. 빨리 푼사람 코드**
- 백준아이디(blpoms)
```python
import sys
# arr1: 헛간
# arr2: 불켜지고 꺼진 여부
# arr3: 갈수있는곳, 방문 체크하는곳(1이면 미방문이면서 갈 수 있는곳, 2이면 방문)
while q:
    tmp = []
    for x, y in q:
        for i, j in arr1[x][y]:
            if not arr2[i][j]: # 불이 안켜졌음
                arr2[i][j] = True # 킨다.
                ans += 1
            if arr3[i][j] == 1: # 현재 위치가 미방문이면서 갈수있으면
                tmp.append((i, j)) # 다음갈곳으로 정하고
                arr3[i][j] = 2 # 방문 표시를한다.
        for xx, yy in dist(x, y): # 인접한곳을 모두 가면서
            if -1 < xx < n and -1 < yy < n and arr3[xx][yy] == 0:
                if arr2[xx][yy]: # 불이 켜져 있으면
                    arr3[xx][yy] = 2 #방문
                    tmp.append((xx, yy)) # 큐에 넣음
                else: # 아니면 미방문이면서 갈 수 있는 곳으로 표시
                    arr3[xx][yy] = 1
    q = tmp
print(ans)
```